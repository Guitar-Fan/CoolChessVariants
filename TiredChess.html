<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tired Chess - Image Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

        body {
            font-family: 'Fredoka One', cursive;
        }

        @keyframes sun-pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 40px 20px #fef08a, 0 0 60px 40px #fde047, inset 0 0 20px 10px #fef9c3;
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 50px 25px #fef08a, 0 0 70px 50px #fde047, inset 0 0 20px 10px #fef9c3;
            }
        }
        
        @keyframes recover-animation {
            0% { transform: scale(1) rotate(15deg); opacity: 0.5; filter: grayscale(80%); }
            50% { transform: scale(1.2) rotate(0deg); opacity: 1; filter: grayscale(0%); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; filter: grayscale(0%); }
        }
        
        .sun {
            animation: sun-pulse 5s infinite ease-in-out;
        }
        
        .piece.recovering {
            animation: recover-animation 0.5s ease-out;
        }
        
        .piece {
             transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.4s ease, filter 0.4s ease;
        }

        .piece.tired .piece-image {
            opacity: 0.5;
            filter: grayscale(80%);
            transform: rotate(15deg) scale(0.9);
        }
    </style>
</head>
<body class="bg-sky-500 overflow-hidden">

    <div class="relative w-screen h-screen flex flex-col items-center justify-center p-4">
        <!-- Sun in the corner -->
        <div class="sun absolute top-8 left-8 w-24 h-24 sm:w-32 sm:h-32 bg-yellow-300 rounded-full"></div>
        
        <!-- Game Title -->
        <h1 class="text-4xl sm:text-6xl text-white text-center font-bold mb-4" style="text-shadow: 3px 3px 0px rgba(0,0,0,0.2);">Tired Chess</h1>

        <!-- Status Panel -->
        <div id="status-panel" class="bg-white/70 backdrop-blur-sm rounded-lg shadow-lg px-6 py-2 mb-4 text-xl sm:text-2xl text-gray-800">
            Current Turn: <span id="turn-indicator" class="font-bold text-sky-700">White</span>
        </div>

        <!-- Chessboard -->
        <div id="chessboard" class="grid grid-cols-8 w-[90vmin] h-[90vmin] sm:w-[80vmin] sm:h-[80vmin] shadow-2xl rounded-lg overflow-hidden border-4 border-yellow-800/50">
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const boardElement = document.getElementById('chessboard');
            const turnIndicator = document.getElementById('turn-indicator');
            let board = [];
            let currentPlayer = 'white';
            let selectedPiece = null;
            let validMoves = [];
            let enPassantTarget = null; // {row, col} of square that can be captured en passant

            // --- Game Configuration ---
            const PIECE_MAX_MOVES = {
                queen: 9,
                rook: 5,
                bishop: 3,
                knight: 3,
                pawn: 1,
                king: 999 
            };
            
            const PIECE_IMAGES = {
                white: {
                    pawn: 'pieces/WhitePawn.png',
                    rook: 'pieces/WhiteRook.png',
                    knight: 'pieces/WhiteKnight.png',
                    bishop: 'pieces/WhiteBishop.png',
                    queen: 'pieces/WhiteQueen.png',
                    king: 'pieces/WhiteKing.png',
                },
                black: {
                    pawn: 'pieces/BlackPawn.png',
                    rook: 'pieces/BlackRook.png',
                    knight: 'pieces/BlackKnight.png',
                    bishop: 'pieces/BlackBishop.png',
                    queen: 'pieces/BlackQueen.webp',
                    king: 'pieces/BlackKing.png',
                }
            };

            function setupBoard() {
                const initialSetup = [
                    ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'],
                    ['pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn'],
                    [], [], [], [],
                    ['pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn', 'pawn'],
                    ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook']
                ];

                for (let r = 0; r < 8; r++) {
                    board[r] = new Array(8).fill(null);
                    for (let c = 0; c < 8; c++) {
                        const square = document.createElement('div');
                        const bgColor = (r + c) % 2 === 0 ? 'bg-green-400' : 'bg-green-600';
                        square.className = `square flex justify-center items-center relative ${bgColor}`;
                        square.dataset.row = r;
                        square.dataset.col = c;
                        boardElement.appendChild(square);
                    }
                }

                initialSetup.forEach((rowSetup, rowIndex) => {
                    const row = rowIndex < 4 ? rowIndex : 7 - (7 - rowIndex);
                    const color = rowIndex < 4 ? 'black' : 'white';
                    if (rowSetup.length > 0) {
                        rowSetup.forEach((pieceType, col) => {
                             board[row][col] = { type: pieceType, color: color, movesLeft: PIECE_MAX_MOVES[pieceType] };
                        });
                    }
                });
                renderBoard();
            }

            function createPieceElement(pieceData) {
                const pieceWrapper = document.createElement('div');
                pieceWrapper.className = 'piece p-1 w-full h-full absolute top-0 left-0 flex justify-center items-center cursor-pointer';
                
                const pieceImage = document.createElement('img');
                pieceImage.src = PIECE_IMAGES[pieceData.color][pieceData.type];
                // In case an image link is broken, this prevents an ugly icon from showing
                pieceImage.onerror = (e) => { e.target.style.display = 'none'; }; 
                pieceImage.className = 'piece-image w-full h-full object-contain transition-all duration-300';
                
                // Add a white drop-shadow to black pieces to make them pop from the dark squares
                if (pieceData.color === 'black') {
                    pieceImage.style.filter = 'drop-shadow(2px 2px 2px rgba(255,255,255,0.3))';
                } else {
                     pieceImage.style.filter = 'drop-shadow(2px 2px 2px rgba(0,0,0,0.3))';
                }

                const moveCounter = document.createElement('div');
                moveCounter.className = 'move-count absolute bottom-0 right-0 text-sm font-bold text-white bg-black/60 rounded-full w-5 h-5 flex items-center justify-center';
                moveCounter.textContent = pieceData.type === 'king' ? 'âˆž' : pieceData.movesLeft;

                pieceWrapper.appendChild(pieceImage);
                pieceWrapper.appendChild(moveCounter);

                if (pieceData.movesLeft === 0) {
                    pieceWrapper.classList.add('tired', 'cursor-not-allowed');
                }
                return pieceWrapper;
            }

            function renderBoard() {
                document.querySelectorAll('.piece, .valid-move-dot, .capture-move').forEach(el => el.remove());
                document.querySelectorAll('.square.bg-yellow-400\\/60').forEach(sq => sq.classList.remove('bg-yellow-400/60', 'rounded-lg'));
                
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const pieceData = board[r][c];
                        if (pieceData) {
                            const pieceElement = createPieceElement(pieceData);
                            getSquareElement(r, c).appendChild(pieceElement);
                        }
                    }
                }
            }
            
            function handleSquareClick(event) {
                const square = event.target.closest('.square');
                if (!square) return;
                const row = parseInt(square.dataset.row);
                const col = parseInt(square.dataset.col);
                const clickedPiece = board[row][col];

                if (selectedPiece) {
                    const isValidMove = validMoves.some(([r, c]) => r === row && c === col);
                    if (isValidMove) {
                        movePiece(selectedPiece, row, col);
                    } else if (clickedPiece && clickedPiece.color === currentPlayer && clickedPiece.movesLeft > 0) {
                        selectedPiece = { piece: clickedPiece, row, col };
                        validMoves = getValidMoves(clickedPiece, row, col);
                        showHighlights();
                    } else {
                        selectedPiece = null;
                        validMoves = [];
                        showHighlights();
                    }
                } else if (clickedPiece && clickedPiece.color === currentPlayer && clickedPiece.movesLeft > 0) {
                    selectedPiece = { piece: clickedPiece, row, col };
                    validMoves = getValidMoves(clickedPiece, row, col);
                    showHighlights();
                }
            }
            
            function getValidMoves(piece, row, col) {
                const moves = [];
                const { type, color } = piece;
                const directions = {
                    rook: [[0, 1], [0, -1], [1, 0], [-1, 0]],
                    bishop: [[1, 1], [1, -1], [-1, 1], [-1, -1]],
                    queen: [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]],
                    king: [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]]
                };

                if (["rook", "bishop", "queen"].includes(type)) {
                    for (const [dr, dc] of directions[type]) {
                        for (let i = 1; i < 8; i++) {
                            const newRow = row + i * dr, newCol = col + i * dc;
                            if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                            if (board[newRow][newCol]) {
                                if (board[newRow][newCol].color !== color) moves.push([newRow, newCol]);
                                break;
                            }
                            moves.push([newRow, newCol]);
                        }
                    }
                }

                if (type === "knight") {
                    const knightMoves = [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]];
                    for (const [dr, dc] of knightMoves) {
                        const newRow = row + dr, newCol = col + dc;
                        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            if (!board[newRow][newCol] || board[newRow][newCol].color !== color) moves.push([newRow, newCol]);
                        }
                    }
                }

                if (type === "king") {
                    for (const [dr, dc] of directions.king) {
                        const newRow = row + dr, newCol = col + dc;
                        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            if (!board[newRow][newCol] || board[newRow][newCol].color !== color) moves.push([newRow, newCol]);
                        }
                    }
                }

                if (type === "pawn") {
                    const dir = color === "white" ? -1 : 1;
                    const startRow = color === "white" ? 6 : 1;
                    // Forward move
                    if (!board[row + dir][col]) {
                        moves.push([row + dir, col]);
                        if (row === startRow && !board[row + 2 * dir][col]) moves.push([row + 2 * dir, col]);
                    }
                    // Captures
                    for (const dc of [-1, 1]) {
                        const targetRow = row + dir;
                        const targetCol = col + dc;
                        if (targetCol >= 0 && targetCol < 8) {
                            // Normal capture
                            if (board[targetRow] && board[targetRow][targetCol] && board[targetRow][targetCol].color !== color) {
                                moves.push([targetRow, targetCol]);
                            }
                            // En passant
                            if (
                                enPassantTarget &&
                                enPassantTarget.row === targetRow &&
                                enPassantTarget.col === targetCol &&
                                ((color === "white" && row === 3) || (color === "black" && row === 4))
                            ) {
                                moves.push([targetRow, targetCol]);
                            }
                        }
                    }
                }
                return moves;
            }

            function showHighlights() {
                document.querySelectorAll('.valid-move-dot, .capture-move').forEach(el => el.remove());
                document.querySelectorAll('.square.bg-yellow-400\\/60').forEach(sq => sq.classList.remove('bg-yellow-400/60', 'rounded-lg'));
                
                if (selectedPiece) {
                    getSquareElement(selectedPiece.row, selectedPiece.col).classList.add('bg-yellow-400/60', 'rounded-lg');
                    validMoves.forEach(([r, c]) => {
                        const square = getSquareElement(r, c);
                        if(board[r][c]) {
                           square.innerHTML += `<div class="capture-move absolute top-0 left-0 w-full h-full border-4 border-red-500/80 rounded-lg"></div>`;
                        } else {
                           square.innerHTML += `<div class="valid-move-dot w-1/3 h-1/3 bg-yellow-200/80 rounded-full"></div>`;
                        }
                    });
                }
            }

            function movePiece(selection, newRow, newCol) {
                const { piece, row: oldRow, col: oldCol } = selection;
                const movingPieceElement = getSquareElement(oldRow, oldCol).querySelector('.piece');
                const newSquare = getSquareElement(newRow, newCol);
                const dx = newSquare.offsetLeft - movingPieceElement.parentElement.offsetLeft;
                const dy = newSquare.offsetTop - movingPieceElement.parentElement.offsetTop;

                movingPieceElement.style.transform = `translate(${dx}px, ${dy}px) scale(1.1)`;
                movingPieceElement.style.zIndex = 10;

                setTimeout(() => {
                    if (piece.type !== 'king') piece.movesLeft--;

                    // En passant capture
                    let didEnPassant = false;
                    if (
                        piece.type === 'pawn' &&
                        enPassantTarget &&
                        newRow === enPassantTarget.row &&
                        newCol === enPassantTarget.col &&
                        Math.abs(newCol - oldCol) === 1 &&
                        board[oldRow][newCol] && board[oldRow][newCol].type === 'pawn' && board[oldRow][newCol].color !== piece.color
                    ) {
                        // Remove the captured pawn
                        board[oldRow][newCol] = null;
                        didEnPassant = true;
                    }

                    board[newRow][newCol] = piece;
                    board[oldRow][oldCol] = null;

                    // Pawn promotion
                    if (piece.type === 'pawn' && (newRow === 0 || newRow === 7)) {
                        piece.type = 'queen';
                        piece.movesLeft = PIECE_MAX_MOVES.queen;
                    }

                    // Set en passant target
                    if (
                        piece.type === 'pawn' &&
                        Math.abs(newRow - oldRow) === 2
                    ) {
                        enPassantTarget = { row: (oldRow + newRow) / 2, col: oldCol };
                    } else {
                        enPassantTarget = null;
                    }

                    const previousPlayer = currentPlayer;
                    currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
                    turnIndicator.textContent = currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1);
                    turnIndicator.style.color = currentPlayer === 'white' ? '#0369a1' : '#3f3f46';

                    for (let r = 0; r < 8; r++) {
                        for (let c = 0; c < 8; c++) {
                            const p = board[r][c];
                            if (p && p.color === previousPlayer && p.movesLeft === 0) {
                                p.movesLeft = PIECE_MAX_MOVES[p.type];
                                // We will re-render, so the "recovering" class will be added there.
                            }
                        }
                    }

                    selectedPiece = null;
                    validMoves = [];
                    renderBoard();
                    for (let r = 0; r < 8; r++) {
                        for (let c = 0; c < 8; c++) {
                            const p = board[r][c];
                            if (p && p.color === previousPlayer && p.movesLeft === PIECE_MAX_MOVES[p.type]) {
                                const recoveredElement = getSquareElement(r, c)?.querySelector('.piece');
                                if (recoveredElement && !recoveredElement.classList.contains('recovering')) {
                                    recoveredElement.classList.add('recovering');
                                    recoveredElement.addEventListener('animationend', () => {
                                        recoveredElement.classList.remove('recovering');
                                    }, { once: true });
                                }
                            }
                        }
                    }

                }, 300);
            }

            function getSquareElement(row, col) {
                return boardElement.querySelector(`[data-row='${row}'][data-col='${col}']`);
            }

            boardElement.addEventListener('click', handleSquareClick);
            setupBoard();
        });
    </script>
</body>
</html>